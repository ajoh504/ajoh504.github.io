<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-03-12T10:22:04-07:00</updated><id>/feed.xml</id><entry><title type="html">A Basic Look at Binary Search</title><link href="/2023/02/18/basic-look-binary-search.html" rel="alternate" type="text/html" title="A Basic Look at Binary Search" /><published>2023-02-18T00:00:00-08:00</published><updated>2023-02-18T00:00:00-08:00</updated><id>/2023/02/18/basic-look-binary-search</id><content type="html" xml:base="/2023/02/18/basic-look-binary-search.html"><![CDATA[<p>The binary search algorithm has a straight-forward use-case: take a sorted collection of integers, search for a key, and return the location where the key is stored. If the key is not found in the collection, then return a value such as <code class="language-plaintext highlighter-rouge">null</code> or <code class="language-plaintext highlighter-rouge">-1</code>.</p>

<p>There is one major advantage to binary search, and that advantage is speed. Binary search achieves this by continually cutting the collection in half until a match is found.</p>

<p>With this in mind, let’s compare binary search to linear search, which begins at one end of the collection then searches one item at a time until a match is found. For small data sets, a linear search is fine. But for large data sets, there is a lot of wasted time searching linearly through a collection. Binary search solves this problem by applying a faster method for finding a key within the collection.</p>

<h3 id="a-data-type-for-binary-search">A Data Type for Binary Search</h3>

<p>To start with, binary search typically requires a sorted array of integers. First, let’s define a C# class with a constructor.</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="nn">BinarySearchSample</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">BinarySearch</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="k">readonly</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">sorted</span><span class="p">;</span>
        <span class="k">public</span> <span class="nf">BinarySearch</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">sorted</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">sorted</span> <span class="p">=</span> <span class="n">sorted</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Using the above example, any client code can create an object from <code class="language-plaintext highlighter-rouge">BinarySearch</code> and construct it by passing a sorted array of integers. The <code class="language-plaintext highlighter-rouge">BinarySearch</code> class will not be responsible for sorting the integers. This task must be handled by the client code.</p>

<p>Now we need a public method that implements the binary search algorithm. We’ll call it <code class="language-plaintext highlighter-rouge">Match()</code>. <code class="language-plaintext highlighter-rouge">Match()</code> has a parameter <code class="language-plaintext highlighter-rouge">key</code> in its method signature, and it will search for <code class="language-plaintext highlighter-rouge">key</code> inside the <code class="language-plaintext highlighter-rouge">sorted</code> array. The method body will contain an integer <code class="language-plaintext highlighter-rouge">low</code> that refers to the starting point and <code class="language-plaintext highlighter-rouge">high</code> that refers to the stopping point.</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kt">int</span> <span class="nf">Match</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">low</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">high</span> <span class="p">=</span> <span class="n">sorted</span><span class="p">.</span><span class="n">Length</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The next part of the algorithm is where we continually cut the array in half. To achieve this, we’ll create a loop that continues as long as <code class="language-plaintext highlighter-rouge">low</code> is less than or equal to <code class="language-plaintext highlighter-rouge">high</code>. Then, we’ll compare the value of <code class="language-plaintext highlighter-rouge">key</code> to the integer stored at the middle of the array. If <code class="language-plaintext highlighter-rouge">key</code> is less than the middle integer, then we reset <code class="language-plaintext highlighter-rouge">high</code> to equal  the middle index minus 1, thus cutting the array in half. If <code class="language-plaintext highlighter-rouge">key</code> is greater than the middle integer, then we reset <code class="language-plaintext highlighter-rouge">low</code> to equal the middle index plus 1, which also cuts the array in half.</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="p">&lt;</span> <span class="n">sorted</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span> <span class="n">high</span> <span class="p">=</span> <span class="n">mid</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="p">&gt;</span> <span class="n">sorted</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span> <span class="n">low</span> <span class="p">=</span> <span class="n">mid</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
</code></pre></div></div>
<p>But how do we get the value of <code class="language-plaintext highlighter-rouge">mid</code>, which refers to the middle index of the sorted array? We could simply divide <code class="language-plaintext highlighter-rouge">high</code> by 2, but this would create a problem. If we’ve previously cut the array in half and reset the value of <code class="language-plaintext highlighter-rouge">low</code>, then <code class="language-plaintext highlighter-rouge">high</code> divided by 2 does not give us the middle index of the current array.</p>

<p>So to get mid, first we subtract <code class="language-plaintext highlighter-rouge">low</code> from <code class="language-plaintext highlighter-rouge">high</code>. If low is greater than zero, this ensures that cutting high in half truly gives us the middle index.</p>

<p>Lastly, we put the code in a <code class="language-plaintext highlighter-rouge">while</code> loop. The loop cuts the array in half whenever a match is not found. If the match is found, the method returns the index where the key is stored. If a match is not found by the end of the loop, the method returns <code class="language-plaintext highlighter-rouge">-1</code>.</p>

<p>Here is the final class:</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="nn">BinarySearchSample</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">BinarySearch</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="k">readonly</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">sorted</span><span class="p">;</span>
        <span class="k">public</span> <span class="nf">BinarySearch</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">sorted</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">sorted</span> <span class="p">=</span> <span class="n">sorted</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">int</span> <span class="nf">Match</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">low</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">high</span> <span class="p">=</span> <span class="n">sorted</span><span class="p">.</span><span class="n">Length</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span>
            <span class="k">while</span><span class="p">(</span><span class="n">low</span> <span class="p">&lt;=</span> <span class="n">high</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">int</span> <span class="n">mid</span> <span class="p">=</span> <span class="n">low</span> <span class="p">+</span> <span class="p">(</span><span class="n">high</span> <span class="p">-</span> <span class="n">low</span><span class="p">)</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="p">&lt;</span> <span class="n">sorted</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span> <span class="n">high</span> <span class="p">=</span> <span class="n">mid</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span>
                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="p">&gt;</span> <span class="n">sorted</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span> <span class="n">low</span> <span class="p">=</span> <span class="n">mid</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
                <span class="k">else</span> <span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>    
<span class="p">}</span>
</code></pre></div></div>

<h3 id="client-code-to-test-binary-search">Client Code to Test Binary Search</h3>

<p>Now we need either a single integer or a set of integers to search for within a <code class="language-plaintext highlighter-rouge">sorted</code> array. For this example, we’ll accept two arguments from the command line. The first argument is the key to search for, and the second argument is a file path. The file path points to a .txt file, which contains a list of integers.</p>

<p>The client code will do the following:</p>
<ol>
  <li>Read the integers from the text file into a List</li>
  <li>Convert the List to a sorted array</li>
  <li>Create a <code class="language-plaintext highlighter-rouge">BinarySearch</code> object, then search for the <code class="language-plaintext highlighter-rouge">key</code> within the sorted array</li>
</ol>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="nn">BinarySearchSample</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
         <span class="c1">// Sample run configuration:</span>
         <span class="c1">// $ BinarySearch.exe 45 integers.txt</span>

        <span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">key</span><span class="p">;</span>
            <span class="kt">string</span> <span class="n">path</span><span class="p">;</span>
            <span class="kt">string</span> <span class="n">errorMessage</span> <span class="p">=</span> <span class="s">"""
</span><span class="n">Error</span><span class="p">:</span> <span class="n">invalid</span> <span class="n">arguments</span>
<span class="n">Sample</span> <span class="n">run</span> <span class="n">configuration</span><span class="p">:</span>
<span class="err">$</span> <span class="n">BinarySearch</span><span class="p">.</span><span class="n">exe</span> <span class="m">45</span> <span class="n">integers</span><span class="p">.</span><span class="n">txt</span>
<span class="s">""";
</span>            <span class="c1">// Check args</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">Length</span> <span class="p">&lt;</span> <span class="m">2</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">errorMessage</span><span class="p">);</span>
                <span class="k">return</span> <span class="m">1</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Parse args[0]</span>
            <span class="k">if</span><span class="p">(</span><span class="n">Int32</span><span class="p">.</span><span class="nf">TryParse</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="m">0</span><span class="p">],</span> <span class="k">out</span> <span class="kt">int</span> <span class="n">keyParsed</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">key</span> <span class="p">=</span> <span class="n">keyParsed</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> 
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">errorMessage</span><span class="p">);</span>
                <span class="k">return</span> <span class="m">1</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Check args[1]</span>
            <span class="k">if</span><span class="p">(</span><span class="n">File</span><span class="p">.</span><span class="nf">Exists</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="m">1</span><span class="p">]))</span>
            <span class="p">{</span>
                <span class="n">path</span> <span class="p">=</span> <span class="n">args</span><span class="p">[</span><span class="m">1</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"File path does not exist."</span><span class="p">);</span>
                <span class="k">return</span> <span class="m">1</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Redirect standard input</span>
            <span class="k">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">reader</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">StreamReader</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">SetIn</span><span class="p">(</span><span class="n">reader</span><span class="p">);</span> 
                <span class="kt">string</span><span class="p">?</span> <span class="n">line</span><span class="p">;</span>
                <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">numbers</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span>

                <span class="k">while</span> <span class="p">((</span><span class="n">line</span> <span class="p">=</span> <span class="n">Console</span><span class="p">.</span><span class="nf">ReadLine</span><span class="p">())</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="c1">// Check values</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">Int32</span><span class="p">.</span><span class="nf">TryParse</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="k">out</span> <span class="kt">int</span> <span class="n">valueParsed</span><span class="p">))</span>
                    <span class="p">{</span>
                        <span class="n">numbers</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">valueParsed</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="k">else</span>
                    <span class="p">{</span>
                        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Cannot parse integer from file."</span><span class="p">);</span>
                        <span class="k">return</span> <span class="m">1</span><span class="p">;</span>
                    <span class="p">}</span>
                    
                <span class="p">}</span>
                
                <span class="c1">// Convert to array</span>
                <span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">numbers</span><span class="p">.</span><span class="n">Count</span><span class="p">];</span>
                <span class="n">arr</span> <span class="p">=</span> <span class="n">numbers</span><span class="p">.</span><span class="nf">ToArray</span><span class="p">();</span>
                <span class="n">Array</span><span class="p">.</span><span class="nf">Sort</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>

                <span class="n">BinarySearch</span> <span class="n">binarySearch</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">BinarySearch</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">binarySearch</span><span class="p">.</span><span class="nf">Match</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="m">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="algorithms" /><summary type="html"><![CDATA[The binary search algorithm has a straight-forward use-case: take a sorted collection of integers, search for a key, and return the location where the key is stored. If the key is not found in the collection, then return a value such as null or -1. There is one major advantage to binary search, and that advantage is speed. Binary search achieves this by continually cutting the collection in half until a match is found. With this in mind, let’s compare binary search to linear search, which begins at one end of the collection then searches one item at a time until a match is found. For small data sets, a linear search is fine. But for large data sets, there is a lot of wasted time searching linearly through a collection. Binary search solves this problem by applying a faster method for finding a key within the collection. A Data Type for Binary Search To start with, binary search typically requires a sorted array of integers. First, let’s define a C# class with a constructor. namespace BinarySearchSample { public class BinarySearch { private readonly int[] sorted; public BinarySearch(int[] sorted) { this.sorted = sorted; } } } Using the above example, any client code can create an object from BinarySearch and construct it by passing a sorted array of integers. The BinarySearch class will not be responsible for sorting the integers. This task must be handled by the client code. Now we need a public method that implements the binary search algorithm. We’ll call it Match(). Match() has a parameter key in its method signature, and it will search for key inside the sorted array. The method body will contain an integer low that refers to the starting point and high that refers to the stopping point. public int Match(int key) { int low = 0; int high = sorted.Length - 1; } The next part of the algorithm is where we continually cut the array in half. To achieve this, we’ll create a loop that continues as long as low is less than or equal to high. Then, we’ll compare the value of key to the integer stored at the middle of the array. If key is less than the middle integer, then we reset high to equal the middle index minus 1, thus cutting the array in half. If key is greater than the middle integer, then we reset low to equal the middle index plus 1, which also cuts the array in half. if (key &lt; sorted[mid]) high = mid - 1; else if (key &gt; sorted[mid]) low = mid + 1; But how do we get the value of mid, which refers to the middle index of the sorted array? We could simply divide high by 2, but this would create a problem. If we’ve previously cut the array in half and reset the value of low, then high divided by 2 does not give us the middle index of the current array. So to get mid, first we subtract low from high. If low is greater than zero, this ensures that cutting high in half truly gives us the middle index. Lastly, we put the code in a while loop. The loop cuts the array in half whenever a match is not found. If the match is found, the method returns the index where the key is stored. If a match is not found by the end of the loop, the method returns -1. Here is the final class: namespace BinarySearchSample { public class BinarySearch { private readonly int[] sorted; public BinarySearch(int[] sorted) { this.sorted = sorted; } public int Match(int key) { int low = 0; int high = sorted.Length - 1; while(low &lt;= high) { int mid = low + (high - low) / 2; if (key &lt; sorted[mid]) high = mid - 1; else if (key &gt; sorted[mid]) low = mid + 1; else return mid; } return -1; } } } Client Code to Test Binary Search Now we need either a single integer or a set of integers to search for within a sorted array. For this example, we’ll accept two arguments from the command line. The first argument is the key to search for, and the second argument is a file path. The file path points to a .txt file, which contains a list of integers. The client code will do the following: Read the integers from the text file into a List Convert the List to a sorted array Create a BinarySearch object, then search for the key within the sorted array namespace BinarySearchSample { public class Program { // Sample run configuration: // $ BinarySearch.exe 45 integers.txt public static int Main(string[] args) { int key; string path; string errorMessage = """ Error: invalid arguments Sample run configuration: $ BinarySearch.exe 45 integers.txt """; // Check args if (args.Length &lt; 2) { Console.WriteLine(errorMessage); return 1; } // Parse args[0] if(Int32.TryParse(args[0], out int keyParsed)) { key = keyParsed; } else { Console.WriteLine(errorMessage); return 1; } // Check args[1] if(File.Exists(args[1])) { path = args[1]; } else { Console.WriteLine("File path does not exist."); return 1; } // Redirect standard input using(var reader = new StreamReader(path)) { Console.SetIn(reader); string? line; List&lt;int&gt; numbers = new List&lt;int&gt;(); while ((line = Console.ReadLine()) != null) { // Check values if(Int32.TryParse(line, out int valueParsed)) { numbers.Add(valueParsed); } else { Console.WriteLine("Cannot parse integer from file."); return 1; } } // Convert to array int[] arr = new int[numbers.Count]; arr = numbers.ToArray(); Array.Sort(arr); BinarySearch binarySearch = new BinarySearch(arr); Console.WriteLine(binarySearch.Match(key)); } return 0; } } }]]></summary></entry></feed>